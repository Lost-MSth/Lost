# 辅助函数：单字节循环左移
def rol(byte, count):
    return ((byte << count) | (byte >> (8 - count))) & 0xFF


# bss byte_4030 get from debugger
key1 = b'in1T_Arr@y_1S_s0_E@sy'
# byte_21A0 get from static analysis
data1 = bytes([0xB4, 0x20, 0x95, 0x44, 0x0C, 0x4E, 0x33, 0x07, 0x84, 0xFB, 0xFB, 0x70, 0x94, 0x1A, 0xD0, 0xA3, 0x1A, 0x5C, 0x42, 0x91, 0x38, 0xE0, 0x4F, 0x61, 0x15, 0x1A, 0x00, 0x51, 0x28, 0xC2, 0x7D, 0x1D, 0x6C, 0xD1,
              0xF1, 0x20, 0x71, 0xDE, 0xCB, 0xD3, 0x2F, 0x3C, 0x8F, 0x9F, 0x61, 0x00, 0x00, 0x00, 0x4C, 0x4B, 0x14, 0x71, 0x7A, 0x64, 0x57, 0x57, 0x65, 0x5C, 0x7A, 0x14, 0x76, 0x7A, 0x56, 0x15, 0x7A, 0x60, 0x65, 0x56, 0x5C])

# ---------------------------------------------

flag1_bytes = bytearray(45)
key1_len = len(key1)

v1 = 0xB4  # -76
rot = (0 & 3) + 1
encrypted_byte = rol(v1 ^ key1[0 % key1_len] ^ 0x3C, rot)
flag1_bytes[0] = encrypted_byte ^ 0xA5

for i in range(0, 45):

    v1 = data1[i]
    rot = (i & 3) + 1
    encrypted_byte = rol(v1 ^ key1[i % key1_len] ^ 0x3C, rot)
    flag1_bytes[i] = encrypted_byte ^ 0xA5

flag1 = flag1_bytes.decode('utf-8')
print(f"Flag 1 (长度: {len(flag1)}): {flag1}")
